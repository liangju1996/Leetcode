## 题目
统计所有小于非负整数 n 的质数的数量。

## 示例:

输入: 10  
输出: 4  
解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。

![思路](https://github.com/liangju1996/Leetcode/blob/master/picture/204.png)
## 思路：
要得到自然数n以内的全部质数，必须把不大于根号n的所有质数的倍数剔除，剩下的就是质数。
```python
def count_primes_py(n):
    """
    求n以内的所有质数个数（纯python代码）
    """
    # 最小的质数是 2
    if n < 2:
        return 0

    isPrime = [1] * n
    # 初始化一个存放n个元素的列表 isPrime，元素初始值为1，表示该元素所在的位置索引值是一个质数，这样一来我们不用单独开辟内存用于存放数字，下标索引天生就可以用来表示自然数。
    isPrime[0] = isPrime[1] = 0   # 0和1不是质数，先排除掉

    # 埃式筛，把不大于根号n的所有质数的倍数剔除
    for i in range(2, int(n ** 0.5) + 1):
        if isPrime[i]:
        # 判断第 i 个数是否已经被赋值为 0 ，即对之前已经排除掉的不是质数的数，不用再对它的倍数进行二次排除。注意：埃式筛要排除的是所有小于等于根号n的质数的倍数，而不是所有小于等于根号n的数的倍数！
            isPrime[i * i:n:i] = [0] * ((n - 1 - i * i) // i + 1)
            #  指定步长参数，进行列表切片赋值，之所以从 i 的平方开始，是因为小于 i 的平方的倍数部分，在它之前就已经被排除掉了。
举个例子：当i等于 5 时，5 的 2 倍为 10 ，所以 10 不是质数，需要排除，但是因为 2 是 10 的最小因数，之前在 i 等于 2 的时候就已经把 10 这个数排除掉了，我们不用再进行二次赋值排除，这样可以增加程序运行的效率。

    return sum(isPrime)

作者：bruce-33
链接：https://leetcode-cn.com/problems/count-primes/solution/pythonzui-you-jie-fa-mei-you-zhi-yi-liao-ba-by-bru/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
